import React, { useState, useEffect, useRef } from 'react';
import * as THREE from 'three';
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';
import PageNav from '../components/PageNav';
import { kinectApi } from '../services/api';
import './KinectLiveCapture.css';

function KinectLiveCapture() {
  const [status, setStatus] = useState({
    isConnected: false,
    isStreaming: false,
    fps: 0,
    totalFrames: 0,
    statusMessage: 'Not initialized',
    errorMessage: null,
  });
  const [isInitializing, setIsInitializing] = useState(false);
  const [pointCount, setPointCount] = useState(0);

  const containerRef = useRef(null);
  const sceneRef = useRef(null);
  const cameraRef = useRef(null);
  const rendererRef = useRef(null);
  const controlsRef = useRef(null);
  const pointCloudRef = useRef(null);
  const eventSourceRef = useRef(null);

  // Initialize Three.js scene
  useEffect(() => {
    if (!containerRef.current) return;

    // Scene setup
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0a0a0f);
    sceneRef.current = scene;

    // Camera setup
    const camera = new THREE.PerspectiveCamera(
      75,
      containerRef.current.clientWidth / containerRef.current.clientHeight,
      0.01,
      100
    );
    camera.position.set(0, 0, 3);
    cameraRef.current = camera;

    // Renderer setup
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(containerRef.current.clientWidth, containerRef.current.clientHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    containerRef.current.appendChild(renderer.domElement);
    rendererRef.current = renderer;

    // Controls
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controlsRef.current = controls;

    // Lighting
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
    scene.add(ambientLight);

    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
    directionalLight.position.set(0, 1, 1);
    scene.add(directionalLight);

    // Grid helper
    const gridHelper = new THREE.GridHelper(10, 10, 0x444444, 0x222222);
    scene.add(gridHelper);

    // Animation loop
    const animate = () => {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    };
    animate();

    // Handle window resize
    const handleResize = () => {
      if (!containerRef.current) return;
      camera.aspect = containerRef.current.clientWidth / containerRef.current.clientHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(containerRef.current.clientWidth, containerRef.current.clientHeight);
    };
    window.addEventListener('resize', handleResize);

    // Cleanup
    return () => {
      window.removeEventListener('resize', handleResize);
      controls.dispose();
      renderer.dispose();
      if (containerRef.current && renderer.domElement) {
        containerRef.current.removeChild(renderer.domElement);
      }
    };
  }, []);

  // Poll status periodically
  useEffect(() => {
    const fetchStatus = async () => {
      try {
        const statusData = await kinectApi.getStatus();
        setStatus(statusData);
      } catch (err) {
        console.error('Failed to fetch Kinect status:', err);
      }
    };

    // Initial fetch
    fetchStatus();

    // Poll every 2 seconds
    const interval = setInterval(fetchStatus, 2000);

    return () => clearInterval(interval);
  }, []);

  // Initialize Kinect sensor
  const handleInitialize = async () => {
    setIsInitializing(true);
    try {
      await kinectApi.initialize();
      const statusData = await kinectApi.getStatus();
      setStatus(statusData);
    } catch (err) {
      console.error('Failed to initialize Kinect:', err);
      alert('Failed to initialize Kinect sensor. Make sure it is connected.');
    } finally {
      setIsInitializing(false);
    }
  };

  // Start streaming
  const handleStartStreaming = async () => {
    try {
      console.log('[KINECT] Starting streaming...');
      await kinectApi.startStreaming();
      console.log('[KINECT] Stream started, beginning frame polling');

      // Start polling for frames instead of SSE
      let pollCount = 0;
      const pollFrames = async () => {
        try {
          pollCount++;
          const frame = await kinectApi.getLatestFrame();

          // Only log every 30th poll to avoid spam (once per second at 33ms intervals)
          if (pollCount % 30 === 0) {
            console.log(`[KINECT] Poll #${pollCount}: Received frame:`, frame ? 'yes' : 'null');
          }

          if (frame) {
            console.log('[KINECT] Frame details:', {
              pollNumber: pollCount,
              pointCount: frame.pointCount,
              pointsLength: frame.points?.length,
              colorsLength: typeof frame.colors === 'string' ? frame.colors.length : frame.colors?.length,
              timestamp: frame.timestamp
            });
            updatePointCloud(frame);
          }
        } catch (err) {
          console.error('[KINECT] Error polling frame (poll #' + pollCount + '):', err);
        }
      };

      // Poll every 33ms (~30 FPS)
      console.log('[KINECT] Setting up polling interval (33ms)');
      const intervalId = setInterval(pollFrames, 33);
      eventSourceRef.current = { close: () => clearInterval(intervalId) };

      // Do one immediate poll
      console.log('[KINECT] Doing initial frame poll');
      pollFrames();

      const statusData = await kinectApi.getStatus();
      setStatus(statusData);
      console.log('[KINECT] Streaming setup complete');
    } catch (err) {
      console.error('[KINECT] Failed to start streaming:', err);
      alert('Failed to start streaming. Make sure Kinect is initialized.');
    }
  };

  // Stop streaming
  const handleStopStreaming = async () => {
    try {
      await kinectApi.stopStreaming();

      // Close SSE connection
      if (eventSourceRef.current) {
        eventSourceRef.current.close();
        eventSourceRef.current = null;
      }

      const statusData = await kinectApi.getStatus();
      setStatus(statusData);
    } catch (err) {
      console.error('Failed to stop streaming:', err);
    }
  };

  // Update point cloud with new frame
  const updatePointCloud = (frame) => {
    console.log('[KINECT] updatePointCloud called with frame:', frame);

    if (!sceneRef.current) {
      console.error('[KINECT] Scene not initialized');
      return;
    }

    // Remove old point cloud
    if (pointCloudRef.current) {
      sceneRef.current.remove(pointCloudRef.current);
      pointCloudRef.current.geometry.dispose();
      pointCloudRef.current.material.dispose();
    }

    // Create new point cloud geometry
    const geometry = new THREE.BufferGeometry();

    // Set position attribute (X, Y, Z)
    const positions = new Float32Array(frame.points);
    console.log('[KINECT] Created positions array:', positions.length, 'floats');
    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

    // Decode colors from base64 string
    let colorBytes;
    if (typeof frame.colors === 'string') {
      // Colors are base64 encoded - decode them
      console.log('[KINECT] Decoding base64 colors string');
      const base64 = frame.colors;
      const binaryString = atob(base64);
      colorBytes = new Uint8Array(binaryString.length);
      for (let i = 0; i < binaryString.length; i++) {
        colorBytes[i] = binaryString.charCodeAt(i);
      }
      console.log('[KINECT] Decoded', colorBytes.length, 'color bytes');
    } else {
      // Colors are already an array
      colorBytes = new Uint8Array(frame.colors);
    }

    // Set color attribute (R, G, B) - normalize to 0-1
    const colors = new Float32Array(colorBytes.length);
    for (let i = 0; i < colorBytes.length; i++) {
      colors[i] = colorBytes[i] / 255.0;
    }
    console.log('[KINECT] Created colors array:', colors.length, 'floats');
    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

    // Create point cloud material
    const material = new THREE.PointsMaterial({
      size: 0.005,
      vertexColors: true,
      sizeAttenuation: true,
    });

    // Create point cloud mesh
    const pointCloud = new THREE.Points(geometry, material);
    pointCloudRef.current = pointCloud;

    sceneRef.current.add(pointCloud);
    console.log('[KINECT] Setting point count to:', frame.pointCount);
    setPointCount(frame.pointCount);
  };

  // Cleanup on unmount
  useEffect(() => {
    return () => {
      if (eventSourceRef.current) {
        eventSourceRef.current.close();
      }
      // Optionally stop streaming when leaving the page
      if (status.isStreaming) {
        kinectApi.stopStreaming().catch(console.error);
      }
    };
  }, [status.isStreaming]);

  return (
    <div className="kinect-live-capture">
      <PageNav
        title="Kinect Live Capture"
        subtitle="Real-time point cloud streaming from Kinect v2"
      />

      <div className="capture-content">
        {/* Control Panel */}
        <div className="control-panel">
          <div className="status-section">
            <h3>Sensor Status</h3>
            <div className="status-grid">
              <div className="status-item">
                <span className="status-label">Connection:</span>
                <span className={`status-value ${status.isConnected ? 'connected' : 'disconnected'}`}>
                  {status.isConnected ? '● Connected' : '○ Disconnected'}
                </span>
              </div>
              <div className="status-item">
                <span className="status-label">Streaming:</span>
                <span className={`status-value ${status.isStreaming ? 'streaming' : ''}`}>
                  {status.isStreaming ? '● Active' : '○ Inactive'}
                </span>
              </div>
              <div className="status-item">
                <span className="status-label">FPS:</span>
                <span className="status-value">{status.fps.toFixed(1)}</span>
              </div>
              <div className="status-item">
                <span className="status-label">Total Frames:</span>
                <span className="status-value">{status.totalFrames.toLocaleString()}</span>
              </div>
              <div className="status-item">
                <span className="status-label">Point Count:</span>
                <span className="status-value">{pointCount.toLocaleString()}</span>
              </div>
              <div className="status-item">
                <span className="status-label">Status:</span>
                <span className="status-value">{status.statusMessage}</span>
              </div>
            </div>
            {status.errorMessage && (
              <div className="error-message">
                <strong>Error:</strong> {status.errorMessage}
              </div>
            )}
          </div>

          <div className="controls-section">
            <h3>Controls</h3>
            <div className="button-group">
              <button
                className="control-btn initialize-btn"
                onClick={handleInitialize}
                disabled={status.isConnected || isInitializing}
              >
                {isInitializing ? 'Initializing...' : 'Initialize Sensor'}
              </button>
              <button
                className="control-btn start-btn"
                onClick={handleStartStreaming}
                disabled={!status.isConnected || status.isStreaming}
              >
                Start Streaming
              </button>
              <button
                className="control-btn stop-btn"
                onClick={handleStopStreaming}
                disabled={!status.isStreaming}
              >
                Stop Streaming
              </button>
            </div>
          </div>

          <div className="info-section">
            <h3>Instructions</h3>
            <ol>
              <li>Connect your Kinect v2 sensor to your computer</li>
              <li>Click "Initialize Sensor" to connect</li>
              <li>Click "Start Streaming" to begin capturing</li>
              <li>Use mouse to rotate, zoom, and pan the point cloud</li>
              <li>Click "Stop Streaming" when done</li>
            </ol>
          </div>
        </div>

        {/* 3D Viewer */}
        <div className="viewer-container" ref={containerRef}>
          {!status.isStreaming && (
            <div className="viewer-overlay">
              <div className="overlay-content">
                <h2>Kinect Live Capture</h2>
                <p>Initialize the sensor and start streaming to see live point cloud data</p>
              </div>
            </div>
          )}
        </div>
      </div>
    </div>
  );
}

export default KinectLiveCapture;
